alloy:
  configMap:
    create: true
    content: |
      
      // ==============================================================================
      // 1. SYSTEM PIPELINE (Tenant: platform-k8s)
      // ==============================================================================

      // --- METRICS: Kubelet/cAdvisor (Cluster Health) ---
      discovery.kubernetes "nodes" {
        role = "node"
      }

      // üõ†Ô∏è ENRICHMENT: Map all K8s Node Labels/Annotations to Metrics
      discovery.relabel "nodes_enriched" {
        targets = discovery.kubernetes.nodes.targets
        
        // 1. Keep Namespace/Node Name
        rule { source_labels = ["__meta_kubernetes_node_name"], target_label = "node" }
        
        // 2. Map ALL Labels (k8s label 'foo' -> metric label 'foo')
        rule { action = "labelmap", regex = "__meta_kubernetes_node_label_(.+)" }
        
        // 3. Map ALL Annotations (k8s annotation 'foo' -> metric label 'annotation_foo')
        rule { 
          action = "labelmap" 
          regex = "__meta_kubernetes_node_annotation_(.+)"
          replacement = "annotation_$1"
        }
      }

      prometheus.scrape "kubelet_scraper" {
        targets    = discovery.relabel.nodes_enriched.output
        scheme     = "https"
        tls_config {
          ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
          insecure_skip_verify = true
        }
        bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        forward_to = [prometheus.remote_write.mimir_system.receiver]
      }

      // --- METRICS: Node Exporter ---
      prometheus.exporter.unix "node_metrics" { }
      
      prometheus.scrape "node_scraper" {
        targets    = prometheus.exporter.unix.node_metrics.targets
        forward_to = [prometheus.remote_write.mimir_system.receiver]
      }

      // --- LOGS: System Pods ---
      discovery.kubernetes "pods" {
        role = "pod"
      }

      // üõ†Ô∏è ENRICHMENT: Map all Pod Labels/Annotations to Logs
      discovery.relabel "logs_k8s" {
        targets = discovery.kubernetes.pods.targets
        
        // Filter System Namespaces
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          action = "keep"
          regex = "kube-system|argocd-system" 
        }

        // Standard Identity Labels
        rule { source_labels = ["__meta_kubernetes_namespace"], target_label = "namespace" }
        rule { source_labels = ["__meta_kubernetes_pod_name"], target_label = "pod" }
        rule { source_labels = ["__meta_kubernetes_pod_container_name"], target_label = "container" }

        // Map ALL Labels & Annotations
        rule { action = "labelmap", regex = "__meta_kubernetes_pod_label_(.+)" }
        rule { 
          action = "labelmap" 
          regex = "__meta_kubernetes_pod_annotation_(.+)"
          replacement = "annotation_$1"
        }
      }

      loki.source.kubernetes "pod_logs_k8s" {
        targets    = discovery.relabel.logs_k8s.output
        forward_to = [loki.write.loki_system.receiver]
      }

      // --- LOGS: Events ---
      loki.source.kubernetes_events "cluster_events" {
        job_name   = "integrations/kubernetes/eventhandler"
        forward_to = [loki.write.loki_system.receiver]
      }

      // --- EXPORTERS (platform-k8s) ---
      prometheus.remote_write "mimir_system" {
        endpoint {
          url = "http://mimir-nginx.observability-prd.svc:80/api/v1/push"
          headers = { "X-Scope-OrgID" = "platform-k8s" }
        }
      }

      loki.write "loki_system" {
        endpoint {
          url = "http://loki-gateway.observability-prd.svc:80/loki/api/v1/push"
          headers = { "X-Scope-OrgID" = "platform-k8s" }
        }
      }

      // ==============================================================================
      // 2. OBSERVABILITY PIPELINE (Tenant: platform-obs)
      // ==============================================================================

      discovery.relabel "logs_obs" {
        targets = discovery.kubernetes.pods.targets
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          action = "keep"
          regex = "observability-prd"
        }
        // Map ALL Labels & Annotations
        rule { source_labels = ["__meta_kubernetes_namespace"], target_label = "namespace" }
        rule { source_labels = ["__meta_kubernetes_pod_name"], target_label = "pod" }
        rule { action = "labelmap", regex = "__meta_kubernetes_pod_label_(.+)" }
        rule { action = "labelmap", regex = "__meta_kubernetes_pod_annotation_(.+)", replacement = "annotation_$1" }
      }

      loki.source.kubernetes "pod_logs_obs" {
        targets    = discovery.relabel.logs_obs.output
        forward_to = [loki.write.loki_obs.receiver]
      }

      loki.write "loki_obs" {
        endpoint {
          url = "http://loki-gateway.observability-prd.svc:80/loki/api/v1/push"
          headers = { "X-Scope-OrgID" = "platform-obs" }
        }
      }

      // ==============================================================================
      // 3. SHOP PIPELINE (Tenant: devteam-1)
      //    Enhanced with automatic K8s Metadata Lookup
      // ==============================================================================

      otelcol.receiver.otlp "shop_receiver" {
        grpc { endpoint = "0.0.0.0:4317" }
        http { endpoint = "0.0.0.0:4318" }

        output {
          metrics = [otelcol.processor.k8sattributes.k8s_enricher.input]
          logs    = [otelcol.processor.k8sattributes.k8s_enricher.input]
          traces  = [otelcol.processor.k8sattributes.k8s_enricher.input]
        }
      }

      // üõ†Ô∏è ENRICHMENT: Lookup K8s Metadata based on Source IP
      otelcol.processor.k8sattributes "k8s_enricher" {
        extract {
          metadata = [
            "k8s.namespace.name",
            "k8s.pod.name",
            "k8s.pod.uid",
            "k8s.deployment.name",
            "k8s.node.name",
          ]
          
          // Grab ALL Labels
          labels = [
            { key_regex = "(.*)", tag_name = "$1" },
          ]
          
          // Grab ALL Annotations (mapped with 'annotation_' prefix)
          annotations = [
            { key_regex = "(.*)", tag_name = "annotation_$1" },
          ]
        }
        
        // Use the incoming connection IP to identify the Pod
        pod_association {
          source { from = "connection" }
        }

        output {
          metrics = [otelcol.processor.batch.shop_batch.input]
          logs    = [otelcol.processor.batch.shop_batch.input]
          traces  = [otelcol.processor.batch.shop_batch.input]
        }
      }

      otelcol.processor.batch "shop_batch" {
        output {
          metrics = [otelcol.exporter.prometheus.mimir_shop_converter.input]
          logs    = [otelcol.exporter.loki.loki_shop.input]
          traces  = [otelcol.exporter.otlp.tempo_shop.input]
        }
      }

      // --- EXPORTERS (devteam-1) ---

      otelcol.exporter.otlp "tempo_shop" {
        client {
          endpoint = "tempo.observability-prd.svc:4317"
          tls { insecure = true }
          headers = { "X-Scope-OrgID" = "devteam-1" }
        }
      }

      otelcol.exporter.loki "loki_shop" {
        forward_to = [loki.write.loki_shop_client.receiver]
      }
      
      loki.write "loki_shop_client" {
        endpoint {
          url = "http://loki-gateway.observability-prd.svc:80/loki/api/v1/push"
          headers = { "X-Scope-OrgID" = "devteam-1" }
        }
      }

      otelcol.exporter.prometheus "mimir_shop_converter" {
        forward_to = [prometheus.remote_write.mimir_shop.receiver]
      }

      prometheus.remote_write "mimir_shop" {
        endpoint {
          url = "http://mimir-nginx.observability-prd.svc:80/api/v1/push"
          headers = { "X-Scope-OrgID" = "devteam-1" }
        }
      }

# Configuration for DaemonSet + HostNetwork 
# (Required for K8sAttributes processor to see real source IPs)
controller:
  type: daemonset
  hostNetwork: true 
  dnsPolicy: ClusterFirstWithHostNet

service:
  enabled: true
  type: ClusterIP
  ports:
    otlp-grpc: { port: 4317, targetPort: 4317, protocol: TCP }
    otlp-http: { port: 4318, targetPort: 4318, protocol: TCP }